<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Webcam Pixel Filter</title>
	<style>
		body {
			background-color: #000000;
			color: #ffffff;
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
		.controls {
			margin: 5px 0;
		}
		button {
			background-color: #333333;
			color: #ffffff;
			border: 1px solid #666666;
			padding: 6px 12px;
			margin: 2px;
			cursor: pointer;
			border-radius: 4px;
		}
		button:hover {
			background-color: #555555;
		}
		#enterBtn {
			background-color: #ff6b6b;
			border-color: #ff5252;
			font-size: 14px;
			padding: 8px 16px;
		}
		#enterBtn:hover {
			background-color: #ff5252;
		}
		label {
			color: #cccccc;
		}
		input[type="range"] {
			margin: 0 10px;
		}
		.main-container {
			display: flex;
			height: 100vh;
			gap: 10px;
		}
		.left-panel {
			flex: 1;
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 10px;
			justify-content: center;
		}
		.right-panel {
			flex: 1;
			display: grid;
			grid-template-columns: repeat(5, 1fr);
			grid-template-rows: repeat(5, 1fr);
			padding: 10px;
			gap: 6px;
			position: relative;
		}
		.main-canvas {
			width: 100%;
			max-width: 500px;
			height: auto;
			border: 2px solid #333;
		}
		.small-canvas {
			width: 126px;
			height: 94px;
			border: 2px solid #666;
		}
	</style>
</head>
<body>

	<video id="video" width="400" height="400" autoplay style="display:none;"></video>
	
	<div class="main-container">
		<div class="left-panel">
			<div class="controls">
				<label>Pixel Size: <input type="range" id="pixelSize" min="4" max="32" value="8"></label>
				<span id="pixelSizeValue">8</span>
			</div>
			<div class="controls">
				<button id="windowBtn">입주하기</button>
			</div>
			<canvas id="mainCanvas" width="500" height="375" class="main-canvas"></canvas>
		</div>
		
		<div class="right-panel" id="rightPanel">
			<!-- Small canvases will be added here -->
		</div>
	</div>

	<script type="text/javascript">
		
		const mainCanvas = document.getElementById('mainCanvas');
		const mainContext = mainCanvas.getContext('2d');
		const video = document.getElementById('video');
		const windowBtn = document.getElementById('windowBtn');
		const pixelSizeSlider = document.getElementById('pixelSize');
		const pixelSizeValue = document.getElementById('pixelSizeValue');
		const rightPanel = document.getElementById('rightPanel');
		let mainAnimation;
		let pixelSize = 8;
		let canvasCount = 0;
		let allAnimations = [];
		let isRecording = false;
		let mediaRecorder;
		let recordedChunks = [];
		let recordedVideos = [];
		let currentColorScheme = 0;

		// Main canvas always uses grayscale (scheme 0)
		currentColorScheme = 0;
		console.log('Main canvas using grayscale scheme');
		
		startVideo();
		startMainAnimation(); // Start animation automatically
		loadRandomVideos(); // Load random videos from database

		windowBtn.onclick = function() {
			if (!isRecording) {
				startRecording();
			} else {
				stopRecording();
			}
		}
		
		pixelSizeSlider.oninput = function() {
			pixelSize = parseInt(this.value);
			pixelSizeValue.textContent = pixelSize;
		}

		function startVideo(){
			navigator.mediaDevices.getUserMedia({video: true})
			.then(stream => {
				video.srcObject = stream;
				video.play();
			})
			.catch(error => {
				console.error('Error accessing webcam:', error);
			});
		}

		function startRecording() {
			// Create a stream from the canvas
			const stream = mainCanvas.captureStream(30); // 30 FPS
			
			mediaRecorder = new MediaRecorder(stream, {
				mimeType: 'video/webm;codecs=vp9'
			});
			
			recordedChunks = [];
			
			mediaRecorder.ondataavailable = function(event) {
				if (event.data.size > 0) {
					recordedChunks.push(event.data);
				}
			};
			
			mediaRecorder.onstop = function() {
				const blob = new Blob(recordedChunks, { type: 'video/webm' });
				const videoUrl = URL.createObjectURL(blob);
				
				// Save to database and display
				saveVideoToDatabase(blob);
				displayRecordedVideo(videoUrl, pixelSize, null, null); // Use current pixel size and random position/color
			};
			
			mediaRecorder.start();
			isRecording = true;
			windowBtn.textContent = '입주하는 중...';
			windowBtn.style.backgroundColor = '#ff4444';
		}

		function stopRecording() {
			if (mediaRecorder && isRecording) {
			mediaRecorder.stop();
			isRecording = false;
			windowBtn.textContent = '입주하기';
			windowBtn.style.backgroundColor = '#ff6b6b';
			}
		}

		function saveVideoToDatabase(videoBlob) {
			// Convert blob to base64 for storage
			const reader = new FileReader();
			reader.onload = function() {
				const videoData = reader.result;
				const timestamp = new Date().toISOString();
				const videoId = 'video_' + Date.now();
				
				// TODO: Save to Firebase database
				console.log('Saving video to database:', {
					id: videoId,
					data: videoData,
					timestamp: timestamp,
					pixelSize: pixelSize,
					colorScheme: currentColorScheme
				});
				
				// For now, store in localStorage as placeholder
				const savedVideos = JSON.parse(localStorage.getItem('savedVideos') || '[]');
				savedVideos.push({
					id: videoId,
					data: videoData,
					timestamp: timestamp,
					pixelSize: pixelSize, // Save the pixel size used when recording
					colorScheme: currentColorScheme // Save the color scheme used when recording
				});
				localStorage.setItem('savedVideos', JSON.stringify(savedVideos));
			};
			reader.readAsDataURL(videoBlob);
		}

		function displayRecordedVideo(videoUrl, savedPixelSize = 8, gridPosition = null, savedColorScheme = null) {
			// Find a random position in the 5x5 grid if not specified
			if (gridPosition === null) {
				const usedPositions = new Set();
				// Get all existing grid positions
				const existingCanvases = rightPanel.querySelectorAll('.small-canvas');
				existingCanvases.forEach(canvas => {
					const row = parseInt(canvas.style.gridRow) - 1;
					const col = parseInt(canvas.style.gridColumn) - 1;
					usedPositions.add(row * 5 + col);
				});
				
			// Find an available position
			let randomPosition;
			do {
				randomPosition = Math.floor(Math.random() * 25); // 0-24 for 5x5 grid
			} while (usedPositions.has(randomPosition) && usedPositions.size < 25);
			
			gridPosition = randomPosition;
			console.log('Selected random position:', gridPosition, 'Used positions:', Array.from(usedPositions));
			}
			
			// Create video element
			const videoElement = document.createElement('video');
			videoElement.src = videoUrl;
			videoElement.controls = false;
			videoElement.autoplay = true;
			videoElement.loop = true;
			videoElement.muted = true;
			videoElement.playsInline = true; // Important for mobile
			videoElement.className = 'small-canvas';
			videoElement.style.width = '100%';
			videoElement.style.height = '100%';
			videoElement.style.border = '2px solid #666';
			videoElement.style.objectFit = 'cover'; // Maintain aspect ratio
			
			// Calculate grid position (0-24 for 5x5 grid)
			const row = Math.floor(gridPosition / 5) + 1;
			const col = (gridPosition % 5) + 1;
			videoElement.style.gridRow = row;
			videoElement.style.gridColumn = col;
			console.log('Video element positioned at row:', row, 'col:', col, 'from position:', gridPosition);
			
			// Add to right panel
			rightPanel.appendChild(videoElement);
			
			// Apply pixel filter effect to the video with saved pixel size and random color scheme
			const randomColorScheme = savedColorScheme !== null ? savedColorScheme : Math.floor(Math.random() * 3) + 1; // 1-3 for colored schemes
			applyPixelFilterToVideo(videoElement, savedPixelSize, randomColorScheme);
			
			// Ensure video plays
			videoElement.play().catch(e => {
				console.log('Video autoplay prevented:', e);
				// Try to play again after user interaction
				document.addEventListener('click', () => {
					videoElement.play().catch(console.log);
				}, { once: true });
			});
		}

		function applyPixelFilterToVideo(videoElement, savedPixelSize = 8, savedColorScheme = 0) {
			// Create canvas for video processing
			const canvas = document.createElement('canvas');
			canvas.width = 126;
			canvas.height = 94;
			canvas.className = 'small-canvas';
			canvas.style.border = '2px solid #666';
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.gridRow = videoElement.style.gridRow;
			canvas.style.gridColumn = videoElement.style.gridColumn;
			canvas.style.objectFit = 'cover'; // Maintain aspect ratio
			const ctx = canvas.getContext('2d');
			
			// Use the saved pixel size and color scheme from when the video was recorded
			const videoPixelSize = savedPixelSize;
			const videoColorScheme = savedColorScheme;
			console.log('Applying pixel filter with size:', videoPixelSize, 'and color scheme:', videoColorScheme); // Debug log
			
			// Hide the video element but keep it for drawing
			videoElement.style.display = 'none';
			
			// Add canvas to the same parent
			videoElement.parentNode.appendChild(canvas);
			
			function processVideo() {
				if (videoElement.readyState >= 2) { // HAVE_CURRENT_DATA
					ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
					
					const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
					const data = imageData.data;
					
					// Apply pixel filter with the saved pixel size
					for (let y = 0; y < canvas.height; y += videoPixelSize) {
						for (let x = 0; x < canvas.width; x += videoPixelSize) {
							const sampleX = Math.min(x + Math.floor(videoPixelSize / 2), canvas.width - 1);
							const sampleY = Math.min(y + Math.floor(videoPixelSize / 2), canvas.height - 1);
							const position = (sampleY * canvas.width * 4) + (sampleX * 4);
							
							const r = data[position];
							const g = data[position + 1];
							const b = data[position + 2];
							const brightness = (r + g + b) / 3;
							
							// Use the saved color scheme from when the video was recorded
							let color = getColorScheme(brightness, videoColorScheme);
							
							ctx.fillStyle = color;
							ctx.fillRect(x, y, videoPixelSize, videoPixelSize);
						}
					}
				}
				
				requestAnimationFrame(processVideo);
			}
			
			// Start processing when video is ready
			videoElement.addEventListener('loadeddata', processVideo);
			videoElement.addEventListener('canplay', processVideo);
			
			// Also start immediately if video is already ready
			if (videoElement.readyState >= 2) {
				processVideo();
			}
		}

		function loadRandomVideos() {
			// Load random videos from database/localStorage
			const savedVideos = JSON.parse(localStorage.getItem('savedVideos') || '[]');
			
			if (savedVideos.length > 0) {
				// Display 3-5 random videos, ensuring variety
				const numVideos = Math.min(Math.floor(Math.random() * 3) + 3, savedVideos.length);
				const usedIndices = new Set();
				const usedPositions = new Set();
				
				for (let i = 0; i < numVideos; i++) {
					let randomIndex;
					do {
						randomIndex = Math.floor(Math.random() * savedVideos.length);
					} while (usedIndices.has(randomIndex) && usedIndices.size < savedVideos.length);
					
					usedIndices.add(randomIndex);
					const randomVideo = savedVideos[randomIndex];
					
					if (randomVideo) {
						// Find a random position in the 5x5 grid
						let randomPosition;
						do {
							randomPosition = Math.floor(Math.random() * 25); // 0-24 for 5x5 grid
						} while (usedPositions.has(randomPosition) && usedPositions.size < 25);
						
						usedPositions.add(randomPosition);
						
						// Pass the saved pixel size and use random color scheme for right panel
						const savedPixelSize = randomVideo.pixelSize || 8; // Default to 8 if not saved
						console.log('Loading video with pixel size:', savedPixelSize, 'at position:', randomPosition); // Debug log
						displayRecordedVideo(randomVideo.data, savedPixelSize, randomPosition, null); // null = random color
					}
				}
			} else {
				// Show placeholder message when no videos exist
				const placeholder = document.createElement('div');
				placeholder.style.color = '#666';
				placeholder.style.textAlign = 'center';
				placeholder.style.padding = '20px';
				placeholder.style.gridColumn = '1 / -1';
				placeholder.style.gridRow = '1 / -1';
				placeholder.style.display = 'flex';
				placeholder.style.alignItems = 'center';
				placeholder.style.justifyContent = 'center';
				placeholder.innerHTML = '아직 창문이 없습니다.<br>첫 번째 창문을 만들어보세요!';
				rightPanel.appendChild(placeholder);
			}
		}

		function getColorScheme(brightness, scheme) {
			switch(scheme) {
				case 0: // Grayscale scheme for main canvas
					if (brightness < 50) return '#000000';
					if (brightness < 100) return '#333333';
					if (brightness < 150) return '#666666';
					if (brightness < 200) return '#999999';
					return '#FFFFFF';
				case 1: // Blue/Purple scheme
					if (brightness < 50) return '#1a1a2e';
					if (brightness < 100) return '#16213e';
					if (brightness < 150) return '#0f3460';
					if (brightness < 200) return '#533483';
					return '#e94560';
				case 2: // Yellow scheme
					if (brightness < 50) return '#2d2d00';
					if (brightness < 100) return '#4d4d00';
					if (brightness < 150) return '#6b6b00';
					if (brightness < 200) return '#999900';
					return '#cccc00';
				case 3: // Cyan/Pink scheme
					if (brightness < 50) return '#0a0a0a';
					if (brightness < 100) return '#1a1a2e';
					if (brightness < 150) return '#16213e';
					if (brightness < 200) return '#0f3460';
					return '#ff6b9d';
			}
		}

		function startMainAnimation() {
			function animate() {
				let tw = mainCanvas.width;
				let th = mainCanvas.height;

				// Clear canvas
				mainContext.clearRect(0, 0, tw, th);

				// Draw video to a temporary canvas to get image data
				let tempCanvas = document.createElement('canvas');
				tempCanvas.width = tw;
				tempCanvas.height = th;
				let tempContext = tempCanvas.getContext('2d');
				tempContext.drawImage(video, 0, 0, tw, th);

				let imageData = tempContext.getImageData(0, 0, tw, th);
				let data = imageData.data;

				// Draw large pixels with current color scheme
				for (let y = 0; y < th; y += pixelSize) {
					for (let x = 0; x < tw; x += pixelSize) {
						// Sample pixel from center of the block
						let sampleX = Math.min(x + Math.floor(pixelSize / 2), tw - 1);
						let sampleY = Math.min(y + Math.floor(pixelSize / 2), th - 1);
						let position = (sampleY * tw * 4) + (sampleX * 4);
						
						let r = data[position];
						let g = data[position + 1];
						let b = data[position + 2];
						
						// Calculate brightness (0-255)
						let brightness = (r + g + b) / 3;
						
						// Choose color based on current color scheme
						let color = getColorScheme(brightness, currentColorScheme);
						
						// Debug log for first few pixels to verify color scheme is working
						if (x < pixelSize * 2 && y < pixelSize * 2) {
							console.log('Main canvas pixel - brightness:', brightness, 'scheme:', currentColorScheme, 'color:', color);
						}
						
						// Draw large pixel
						mainContext.fillStyle = color;
						mainContext.fillRect(x, y, pixelSize, pixelSize);
					}
				}

				mainAnimation = requestAnimationFrame(animate);
			}
			
			animate();
		}


		function stopAllAnimations() {
			// Stop main animation
			if (mainAnimation) {
				cancelAnimationFrame(mainAnimation);
			}
			
			// Stop all small canvas animations
			allAnimations.forEach(animationId => {
				cancelAnimationFrame(animationId);
			});
			allAnimations = [];
		}

		// Add keyboard shortcut to stop animations (ESC key)
		document.addEventListener('keydown', function(event) {
			if (event.key === 'Escape') {
				stopAllAnimations();
			}
		});

		// Function to create test videos with different pixel sizes (for testing)
		function createTestVideos() {
			const testPixelSizes = [4, 8, 16, 24, 32];
			const savedVideos = JSON.parse(localStorage.getItem('savedVideos') || '[]');
			
			// Only create test videos if we don't have enough variety
			if (savedVideos.length < 5) {
				testPixelSizes.forEach((size, index) => {
					// Create a simple test video data
					const testVideoData = {
						id: 'test_video_' + index,
						data: 'data:video/webm;base64,', // Placeholder
						timestamp: new Date().toISOString(),
						pixelSize: size
					};
					savedVideos.push(testVideoData);
				});
				localStorage.setItem('savedVideos', JSON.stringify(savedVideos));
				console.log('Created test videos with pixel sizes:', testPixelSizes);
			}
		}

		// Uncomment the line below to create test videos
		// createTestVideos();



        


	</script>


<script type="module">
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
    // TODO: Add SDKs for Firebase products that you want to use
    // https://firebase.google.com/docs/web/setup#available-libraries
  
    // Your web app's Firebase configuration
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
      apiKey: "AIzaSyAZp1CrD4A0yceTrQiyVSmbmLcOL-lYZc8",
      authDomain: "apartment-5abca.firebaseapp.com",
      projectId: "apartment-5abca",
      storageBucket: "apartment-5abca.firebasestorage.app",
      messagingSenderId: "94466801283",
      appId: "1:94466801283:web:62a58e33d915ea8711a5b6",
      measurementId: "G-BMKBC64ER4"
    };
  
    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);

    
  </script>

    

</body>
</html>
