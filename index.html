<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Webcam Pixel Filter</title>
	<style>
		body {
			background: radial-gradient(circle at center, #111111 0%, #000000 100%);
			color: #ffffff;
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 0;
			overflow: hidden;
			width: 100vw;
			height: 100vh;
			max-width: 100vw;
			max-height: 100vh;
		}
		.controls {
			margin: 5px 0;
		}
		button {
			background-color: #333333;
			color: #ffffff;
			border: 1px solid #666666;
			padding: 6px 12px;
			margin: 2px;
			cursor: pointer;
			border-radius: 4px;
		}
		button:hover {
			background-color: #555555;
		}
		#enterBtn {
			background-color: #ff6b6b;
			border-color: #ff5252;
			font-size: 14px;
			padding: 8px 16px;
		}
		#enterBtn:hover {
			background-color: #ff5252;
		}
		label {
			color: #cccccc;
		}
		input[type="range"] {
			margin: 0 10px;
		}
		.main-container {
			display: flex;
			height: 100vh;
			gap: 8px;
			overflow: hidden;
			width: 100vw;
			max-width: 100vw;
		}
		.left-panel {
			flex: 0 0 30%;
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 10px;
			justify-content: center;
		}
		.right-panel {
			flex: 0 0 60%;
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			grid-template-rows: repeat(5, 1fr);
			grid-auto-flow: row;
			grid-auto-rows: 1fr;
			gap: 12px;
			background: #000000;
			border-radius: 0;
			box-shadow: none;
			z-index: 1;
			padding: 15px;
			max-width: 60%;
			overflow: hidden;
		}
		.main-canvas {
			width: 100%;
			max-width: 500px;
			height: auto;
		}
		.small-canvas {
			width: 80%;
			height: 80%;
			border: 1px solid #333;
			border-radius: 0;
			background: #000;
			box-shadow: none;
			transition: all 0.3s ease;
			position: relative;
			overflow: visible;
			opacity: 0.8;
			z-index: 2;
			cursor: pointer;
			margin: auto;
		}
		
		.small-canvas:hover {
			filter: brightness(2.5) saturate(1.8) contrast(1.5) hue-rotate(5deg);
			transform: scale(1.07);
			box-shadow: none;
			animation: pulse-glow 0.6s ease-in-out infinite alternate;
		}
		
		@keyframes pulse-glow {
			0% {
				filter: brightness(2.5) saturate(1.8) contrast(1.5) hue-rotate(5deg);
				box-shadow: none;
			}
			100% {
				filter: brightness(3.0) saturate(2.2) contrast(1.8) hue-rotate(8deg);
				box-shadow: none;
			}
		}
		
		/* 가우시안 흐림 오버레이 효과 */
		.small-canvas::after {
			content: '';
			position: absolute;
			top: -20px;
			left: -20px;
			right: -20px;
			bottom: -20px;
			background: inherit;
			filter: blur(15px) brightness(1.2);
			opacity: 0.6;
			z-index: 0;
			pointer-events: none;
		}
		
		/* 다양한 창문 조명 색상 - 강력한 글로우 효과 */
		.small-canvas.red-glow {
			background: 
				radial-gradient(circle at center, rgba(250, 50, 50, 0.9) 0%, rgba(250, 50, 50, 0.7) 30%, rgba(250, 50, 50, 0.3) 60%, transparent 100%),
				linear-gradient(135deg, #fa3232, #ff6b6b);
			box-shadow: 
				inset 0 0 40px rgba(250, 50, 50, 0.9),
				inset 0 0 80px rgba(250, 50, 50, 0.6),
				inset 0 0 120px rgba(250, 50, 50, 0.4),
				inset 0 0 160px rgba(250, 50, 50, 0.2),
				0 0 30px rgba(250, 50, 50, 0.9),
				0 0 60px rgba(250, 50, 50, 0.7),
				0 0 90px rgba(250, 50, 50, 0.5),
				0 0 120px rgba(250, 50, 50, 0.3),
				0 0 150px rgba(250, 50, 50, 0.1);
			filter: brightness(1.3) saturate(1.5) contrast(1.2);
		}
		
		.small-canvas.warm-yellow {
			background: 
				radial-gradient(circle at center, rgba(254, 230, 159, 0.9) 0%, rgba(254, 230, 159, 0.7) 30%, rgba(254, 230, 159, 0.3) 60%, transparent 100%),
				linear-gradient(135deg, #fee69f, #fdd835);
			box-shadow: 
				inset 0 0 40px rgba(254, 230, 159, 0.9),
				inset 0 0 80px rgba(254, 230, 159, 0.6),
				inset 0 0 120px rgba(254, 230, 159, 0.4),
				inset 0 0 160px rgba(254, 230, 159, 0.2),
				0 0 30px rgba(254, 230, 159, 0.9),
				0 0 60px rgba(254, 230, 159, 0.7),
				0 0 90px rgba(254, 230, 159, 0.5),
				0 0 120px rgba(254, 230, 159, 0.3),
				0 0 150px rgba(254, 230, 159, 0.1);
			filter: brightness(1.3) saturate(1.5) contrast(1.2);
		}
		
		.small-canvas.cream-light {
			background: 
				radial-gradient(circle at center, rgba(254, 235, 210, 0.9) 0%, rgba(254, 235, 210, 0.7) 30%, rgba(254, 235, 210, 0.3) 60%, transparent 100%),
				linear-gradient(135deg, #feebd2, #fff3e0);
			box-shadow: 
				inset 0 0 40px rgba(254, 235, 210, 0.9),
				inset 0 0 80px rgba(254, 235, 210, 0.6),
				inset 0 0 120px rgba(254, 235, 210, 0.4),
				inset 0 0 160px rgba(254, 235, 210, 0.2),
				0 0 30px rgba(254, 235, 210, 0.9),
				0 0 60px rgba(254, 235, 210, 0.7),
				0 0 90px rgba(254, 235, 210, 0.5),
				0 0 120px rgba(254, 235, 210, 0.3),
				0 0 150px rgba(254, 235, 210, 0.1);
			filter: brightness(1.3) saturate(1.5) contrast(1.2);
		}
		
		.small-canvas.orange-warm {
			background: 
				radial-gradient(circle at center, rgba(230, 136, 14, 0.9) 0%, rgba(230, 136, 14, 0.7) 30%, rgba(230, 136, 14, 0.3) 60%, transparent 100%),
				linear-gradient(135deg, #e6880e, #ff9800);
			box-shadow: 
				inset 0 0 40px rgba(230, 136, 14, 0.9),
				inset 0 0 80px rgba(230, 136, 14, 0.6),
				inset 0 0 120px rgba(230, 136, 14, 0.4),
				inset 0 0 160px rgba(230, 136, 14, 0.2),
				0 0 30px rgba(230, 136, 14, 0.9),
				0 0 60px rgba(230, 136, 14, 0.7),
				0 0 90px rgba(230, 136, 14, 0.5),
				0 0 120px rgba(230, 136, 14, 0.3),
				0 0 150px rgba(230, 136, 14, 0.1);
			filter: brightness(1.3) saturate(1.5) contrast(1.2);
		}
		
		.small-canvas.blue-deep {
			background: 
				radial-gradient(circle at center, rgba(38, 59, 180, 0.9) 0%, rgba(38, 59, 180, 0.7) 30%, rgba(38, 59, 180, 0.3) 60%, transparent 100%),
				linear-gradient(135deg, #263bb4, #3f51b5);
			box-shadow: 
				inset 0 0 40px rgba(38, 59, 180, 0.9),
				inset 0 0 80px rgba(38, 59, 180, 0.6),
				inset 0 0 120px rgba(38, 59, 180, 0.4),
				inset 0 0 160px rgba(38, 59, 180, 0.2),
				0 0 30px rgba(38, 59, 180, 0.9),
				0 0 60px rgba(38, 59, 180, 0.7),
				0 0 90px rgba(38, 59, 180, 0.5),
				0 0 120px rgba(38, 59, 180, 0.3),
				0 0 150px rgba(38, 59, 180, 0.1);
			filter: brightness(1.3) saturate(1.5) contrast(1.2);
		}
		
		.apartment-title {
			color: #ffffff;
			font-size: 28px;
			font-weight: bold;
			margin: 0 0 10px 0;
			text-align: center;
		}
		.instruction-text {
			color: #888888;
			font-size: 12px;
			text-align: center;
			margin: 10px 0 0 0;
			line-height: 1.4;
		}
	</style>
</head>
<body>

	<video id="video" width="400" height="400" autoplay style="display:none;"></video>
	
	<div class="main-container">
		<div class="left-panel">
			<h1 class="apartment-title">off the light</h1>
			<div class="controls">
				<label>Pixel Size: <input type="range" id="pixelSize" min="4" max="32" value="8"></label>
				<span id="pixelSizeValue">8</span>
			</div>
			<div class="controls">
				<button id="windowBtn">불 키기</button>
				<div id="countdown" style="display: none; position: fixed; top: 20px; left: 20px; font-size: 48px; color: #ff6b6b; font-weight: bold; z-index: 1000; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">5</div>
			</div>
			<canvas id="mainCanvas" width="500" height="375" class="main-canvas"></canvas>
			<p class="instruction-text">불 키기 버튼을 눌러 야작해보세요. 오른쪽의 창문 물을 꺼서 학생들을 재워보세요.</p>
		</div>
		
		<div class="right-panel" id="rightPanel">
			<!-- Small canvases will be added here -->
		</div>
	</div>

	<script type="text/javascript">
		
		const mainCanvas = document.getElementById('mainCanvas');
		const mainContext = mainCanvas.getContext('2d');
		const video = document.getElementById('video');
		const windowBtn = document.getElementById('windowBtn');
		const pixelSizeSlider = document.getElementById('pixelSize');
		const pixelSizeValue = document.getElementById('pixelSizeValue');
		const rightPanel = document.getElementById('rightPanel');
		let mainAnimation;
		let pixelSize = 8;
		let canvasCount = 0;
		let allAnimations = [];
		let isRecording = false;
		let mediaRecorder;
		let recordedChunks = [];
		let recordedVideos = [];
		let currentColorScheme = 0;

		// Main canvas always uses grayscale (scheme 0)
		currentColorScheme = 0;
		console.log('Main canvas using grayscale scheme');
		
		startVideo();
		startMainAnimation(); // Start animation automatically
		loadRandomVideos(); // Load random videos from database

		windowBtn.onclick = function() {
			if (!isRecording) {
				startCountdownAndRecording();
			}
			// 녹화 중에는 수동 중지 불가능 - 자동으로 5초 후 중지됨
		}
		
		pixelSizeSlider.oninput = function() {
			pixelSize = parseInt(this.value);
			pixelSizeValue.textContent = pixelSize;
		}

		function startVideo(){
			navigator.mediaDevices.getUserMedia({video: true})
			.then(stream => {
				video.srcObject = stream;
				video.play();
			})
			.catch(error => {
				console.error('Error accessing webcam:', error);
			});
		}

		function startCountdownAndRecording() {
			const countdownElement = document.getElementById('countdown');
			const windowBtn = document.getElementById('windowBtn');
			
			// Disable button during countdown
			windowBtn.disabled = true;
			windowBtn.textContent = '불 키는 중';
			windowBtn.style.backgroundColor = '#666';
			
			// Show countdown
			countdownElement.style.display = 'block';
			
			// Start recording immediately during countdown
			startRecording();
			
			let count = 5;
			countdownElement.textContent = count;
			
			const countdownInterval = setInterval(() => {
				count--;
				countdownElement.textContent = count;
				
				if (count <= 0) {
					clearInterval(countdownInterval);
					countdownElement.style.display = 'none';
					
					// Stop recording after countdown
					stopRecording();
				}
			}, 1000);
		}

		function startRecording() {
			// Create a stream from the canvas
			const stream = mainCanvas.captureStream(30); // 30 FPS
			
			mediaRecorder = new MediaRecorder(stream, {
				mimeType: 'video/webm;codecs=vp9'
			});
			
			recordedChunks = [];
			
			mediaRecorder.ondataavailable = function(event) {
				if (event.data.size > 0) {
					recordedChunks.push(event.data);
				}
			};
			
			mediaRecorder.onstop = function() {
				const blob = new Blob(recordedChunks, { type: 'video/webm' });
				const videoUrl = URL.createObjectURL(blob);
				
				// Save to database and display
				saveVideoToDatabase(blob);
				displayRecordedVideo(videoUrl, pixelSize, null, null); // Use current pixel size and random position/color
			};
			
			mediaRecorder.start();
			isRecording = true;
			
			// Update button state - 녹화 중에는 비활성화
			const windowBtn = document.getElementById('windowBtn');
			windowBtn.disabled = true;
			windowBtn.textContent = '녹화 중...';
			windowBtn.style.backgroundColor = '#666';
		}

		function stopRecording() {
			if (mediaRecorder && isRecording) {
				mediaRecorder.stop();
				isRecording = false;
				
				// Update button state - 녹화 완료 후 다시 활성화
				const windowBtn = document.getElementById('windowBtn');
				windowBtn.disabled = false;
				windowBtn.textContent = '불 키기';
				windowBtn.style.backgroundColor = '#ff6b6b';
			}
		}

		function saveVideoToDatabase(videoBlob) {
			// Convert blob to base64 for storage
			const reader = new FileReader();
			reader.onload = function() {
				const videoData = reader.result;
				const timestamp = new Date().toISOString();
				const videoId = 'video_' + Date.now();
				
				// TODO: Save to Firebase database
				console.log('Saving video to database:', {
					id: videoId,
					data: videoData,
					timestamp: timestamp,
					pixelSize: pixelSize,
					colorScheme: currentColorScheme
				});
				
				// For now, store in localStorage as placeholder
				const savedVideos = JSON.parse(localStorage.getItem('savedVideos') || '[]');
				savedVideos.push({
					id: videoId,
					data: videoData,
					timestamp: timestamp,
					pixelSize: pixelSize, // Save the pixel size used when recording
					colorScheme: currentColorScheme // Save the color scheme used when recording
				});
				localStorage.setItem('savedVideos', JSON.stringify(savedVideos));
			};
			reader.readAsDataURL(videoBlob);
		}

		function displayRecordedVideo(videoUrl, savedPixelSize = 8, gridPosition = null, savedColorScheme = null) {
			// Find a random position in the 4x5 grid if not specified
			if (gridPosition === null) {
				const usedPositions = new Set();
				// Get all existing grid positions (canvases in grid cells)
				const existingCanvases = rightPanel.querySelectorAll('.small-canvas');
				existingCanvases.forEach(canvas => {
					const gridCell = canvas.closest('.grid-cell');
					if (gridCell) {
						usedPositions.add(parseInt(gridCell.dataset.gridPosition));
					}
				});
				
			// Find an available position
			let randomPosition;
			do {
				randomPosition = Math.floor(Math.random() * 20); // 0-19 for 4x5 grid
			} while (usedPositions.has(randomPosition) && usedPositions.size < 20);
			
			gridPosition = randomPosition;
			console.log('Selected random position:', gridPosition, 'Used positions:', Array.from(usedPositions));
			}
			
			// Create video element
			const videoElement = document.createElement('video');
			videoElement.src = videoUrl;
			videoElement.controls = false;
			videoElement.autoplay = true;
			videoElement.loop = true;
			videoElement.muted = true;
			videoElement.playsInline = true; // Important for mobile
			videoElement.className = 'small-canvas';
			videoElement.style.width = '80%';
			videoElement.style.height = '80%';
			videoElement.style.margin = 'auto';
			videoElement.style.border = '1px solid #333';
			videoElement.style.borderRadius = '0';
			videoElement.style.boxShadow = 'none';
			videoElement.style.objectFit = 'cover'; // Maintain aspect ratio
			videoElement.style.overflow = 'visible';
			videoElement.style.opacity = '0.8';
			
			// 랜덤한 조명 색상 적용
			const lightColors = ['red-glow', 'warm-yellow', 'cream-light', 'orange-warm', 'blue-deep'];
			const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
			videoElement.classList.add(randomColor);
			
			console.log('Video element positioned at grid position:', gridPosition);
			
			// Add to the corresponding grid cell
			const gridCell = rightPanel.querySelector(`[data-grid-position="${gridPosition}"]`);
			if (gridCell) {
				gridCell.appendChild(videoElement);
			} else {
				// Fallback: create grid cell if it doesn't exist
				const newGridCell = document.createElement('div');
				newGridCell.className = 'grid-cell';
				newGridCell.dataset.gridPosition = gridPosition;
				
				const row = Math.floor(gridPosition / 4) + 1;
				const col = (gridPosition % 4) + 1;
				
				newGridCell.style.gridRow = row;
				newGridCell.style.gridColumn = col;
				newGridCell.style.width = '100%';
				newGridCell.style.height = '100%';
				newGridCell.style.position = 'relative';
				
				newGridCell.appendChild(videoElement);
				rightPanel.appendChild(newGridCell);
			}
			
			// Add click event to remove the video element
			videoElement.addEventListener('click', function() {
				videoElement.remove();
			});
			
			// Apply pixel filter effect to the video with saved pixel size and random color scheme
			const randomColorScheme = savedColorScheme !== null ? savedColorScheme : Math.floor(Math.random() * 3) + 1; // 1-3 for colored schemes
			applyPixelFilterToVideo(videoElement, savedPixelSize, randomColorScheme);
			
			// Ensure video plays
			videoElement.play().catch(e => {
				console.log('Video autoplay prevented:', e);
				// Try to play again after user interaction
				document.addEventListener('click', () => {
					videoElement.play().catch(console.log);
				}, { once: true });
			});
		}

		function applyPixelFilterToVideo(videoElement, savedPixelSize = 8, savedColorScheme = 0) {
			// Create canvas for video processing
			const canvas = document.createElement('canvas');
			canvas.width = 126;
			canvas.height = 94;
			canvas.className = 'small-canvas';
			canvas.style.border = '1px solid #333';
			canvas.style.borderRadius = '0';
			canvas.style.boxShadow = 'none';
			canvas.style.width = '80%';
			canvas.style.height = '80%';
			canvas.style.margin = 'auto';
			// Canvas doesn't need grid positioning as it's inside a grid cell
			canvas.style.objectFit = 'cover'; // Maintain aspect ratio
			canvas.style.overflow = 'visible';
			canvas.style.opacity = '0.8';
			
			// 비디오와 같은 조명 색상 적용
			const lightColors = ['red-glow', 'warm-yellow', 'cream-light', 'orange-warm', 'blue-deep'];
			const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
			canvas.classList.add(randomColor);
			const ctx = canvas.getContext('2d');
			
			// Use the saved pixel size and color scheme from when the video was recorded
			const videoPixelSize = savedPixelSize;
			const videoColorScheme = savedColorScheme;
			console.log('Applying pixel filter with size:', videoPixelSize, 'and color scheme:', videoColorScheme); // Debug log
			
			// Hide the video element but keep it for drawing
			videoElement.style.display = 'none';
			
			// Add canvas to the same parent
			videoElement.parentNode.appendChild(canvas);
			
			// Add click event to remove both canvas and video element
			canvas.addEventListener('click', function() {
				canvas.remove();
				videoElement.remove();
			});
			
			function processVideo() {
				if (videoElement.readyState >= 2) { // HAVE_CURRENT_DATA
					ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
					
					const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
					const data = imageData.data;
					
					// Apply pixel filter with the saved pixel size
					for (let y = 0; y < canvas.height; y += videoPixelSize) {
						for (let x = 0; x < canvas.width; x += videoPixelSize) {
							const sampleX = Math.min(x + Math.floor(videoPixelSize / 2), canvas.width - 1);
							const sampleY = Math.min(y + Math.floor(videoPixelSize / 2), canvas.height - 1);
							const position = (sampleY * canvas.width * 4) + (sampleX * 4);
							
							const r = data[position];
							const g = data[position + 1];
							const b = data[position + 2];
							const brightness = (r + g + b) / 3;
							
							// Use the saved color scheme from when the video was recorded
							let color = getColorScheme(brightness, videoColorScheme);
							
							ctx.fillStyle = color;
							ctx.fillRect(x, y, videoPixelSize, videoPixelSize);
						}
					}
				}
				
				requestAnimationFrame(processVideo);
			}
			
			// Start processing when video is ready
			videoElement.addEventListener('loadeddata', processVideo);
			videoElement.addEventListener('canplay', processVideo);
			
			// Also start immediately if video is already ready
			if (videoElement.readyState >= 2) {
				processVideo();
			}
		}

		function loadRandomVideos() {
			// Load random videos from database/localStorage
			const savedVideos = JSON.parse(localStorage.getItem('savedVideos') || '[]');
			
			if (savedVideos.length > 0) {
				// Display 3-6 random videos, ensuring variety
				const numVideos = Math.min(Math.floor(Math.random() * 4) + 3, savedVideos.length);
				const usedIndices = new Set();
				const usedPositions = new Set();
				
				// Get all existing grid positions (canvases in grid cells)
				const existingCanvases = rightPanel.querySelectorAll('.small-canvas');
				existingCanvases.forEach(canvas => {
					const gridCell = canvas.closest('.grid-cell');
					if (gridCell) {
						usedPositions.add(parseInt(gridCell.dataset.gridPosition));
					}
				});
				
				for (let i = 0; i < numVideos; i++) {
					let randomIndex;
					do {
						randomIndex = Math.floor(Math.random() * savedVideos.length);
					} while (usedIndices.has(randomIndex) && usedIndices.size < savedVideos.length);
					
					usedIndices.add(randomIndex);
					const randomVideo = savedVideos[randomIndex];
					
					if (randomVideo) {
					// Find a random position in the 4x5 grid
					let randomPosition;
					do {
						randomPosition = Math.floor(Math.random() * 20); // 0-19 for 4x5 grid
					} while (usedPositions.has(randomPosition) && usedPositions.size < 20);
						
						usedPositions.add(randomPosition);
						
						// Pass the saved pixel size and use random color scheme for right panel
						const savedPixelSize = randomVideo.pixelSize || 8; // Default to 8 if not saved
						console.log('Loading video with pixel size:', savedPixelSize, 'at position:', randomPosition); // Debug log
						displayRecordedVideo(randomVideo.data, savedPixelSize, randomPosition, null); // null = random color
					}
				}
			} else {
				// Create default windows when no videos exist
				createDefaultWindows();
			}
		}
		
		function createDefaultWindows() {
			// Create 20 grid cells first to maintain fixed positions
			for (let i = 0; i < 20; i++) {
				const gridCell = document.createElement('div');
				gridCell.className = 'grid-cell';
				gridCell.dataset.gridPosition = i;
				
				// Calculate grid position for 4x5 grid
				const row = Math.floor(i / 4) + 1;
				const col = (i % 4) + 1;
				
				gridCell.style.gridRow = row;
				gridCell.style.gridColumn = col;
				gridCell.style.width = '100%';
				gridCell.style.height = '100%';
				gridCell.style.position = 'relative';
				
				rightPanel.appendChild(gridCell);
			}
			
			// Create 20 windows (4x5 grid) with fixed positions
			const lightColors = ['red-glow', 'warm-yellow', 'cream-light', 'orange-warm', 'blue-deep'];
			
			for (let i = 0; i < 20; i++) {
				const windowDiv = document.createElement('div');
				windowDiv.className = 'small-canvas';
				windowDiv.dataset.gridPosition = i; // Store original position
				
				// Apply random color
				const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
				windowDiv.classList.add(randomColor);
				
				// Add click event to remove the window
				windowDiv.addEventListener('click', function() {
					windowDiv.remove();
				});
				
				// Add to the corresponding grid cell
				const gridCell = rightPanel.querySelector(`[data-grid-position="${i}"]`);
				gridCell.appendChild(windowDiv);
			}
		}

		function getColorScheme(brightness, scheme) {
			switch(scheme) {
				case 0: // Grayscale scheme for main canvas
					if (brightness < 50) return '#000000';
					if (brightness < 100) return '#333333';
					if (brightness < 150) return '#666666';
					if (brightness < 200) return '#999999';
					return '#FFFFFF';
				case 1: // Blue/Purple scheme
					if (brightness < 50) return '#1a1a2e';
					if (brightness < 100) return '#16213e';
					if (brightness < 150) return '#0f3460';
					if (brightness < 200) return '#533483';
					return '#e94560';
				case 2: // Yellow scheme
					if (brightness < 50) return '#2d2d00';
					if (brightness < 100) return '#4d4d00';
					if (brightness < 150) return '#6b6b00';
					if (brightness < 200) return '#999900';
					return '#cccc00';
				case 3: // Cyan/Pink scheme
					if (brightness < 50) return '#0a0a0a';
					if (brightness < 100) return '#1a1a2e';
					if (brightness < 150) return '#16213e';
					if (brightness < 200) return '#0f3460';
					return '#ff6b9d';
			}
		}

		function startMainAnimation() {
			function animate() {
				let tw = mainCanvas.width;
				let th = mainCanvas.height;

				// Clear canvas
				mainContext.clearRect(0, 0, tw, th);

				// Draw video to a temporary canvas to get image data
				let tempCanvas = document.createElement('canvas');
				tempCanvas.width = tw;
				tempCanvas.height = th;
				let tempContext = tempCanvas.getContext('2d');
				tempContext.drawImage(video, 0, 0, tw, th);

				let imageData = tempContext.getImageData(0, 0, tw, th);
				let data = imageData.data;

				// Draw large pixels with current color scheme
				for (let y = 0; y < th; y += pixelSize) {
					for (let x = 0; x < tw; x += pixelSize) {
						// Sample pixel from center of the block
						let sampleX = Math.min(x + Math.floor(pixelSize / 2), tw - 1);
						let sampleY = Math.min(y + Math.floor(pixelSize / 2), th - 1);
						let position = (sampleY * tw * 4) + (sampleX * 4);
						
						let r = data[position];
						let g = data[position + 1];
						let b = data[position + 2];
						
						// Calculate brightness (0-255)
						let brightness = (r + g + b) / 3;
						
						// Choose color based on current color scheme
						let color = getColorScheme(brightness, currentColorScheme);
						
						// Debug log for first few pixels to verify color scheme is working
						if (x < pixelSize * 2 && y < pixelSize * 2) {
							console.log('Main canvas pixel - brightness:', brightness, 'scheme:', currentColorScheme, 'color:', color);
						}
						
						// Draw large pixel
						mainContext.fillStyle = color;
						mainContext.fillRect(x, y, pixelSize, pixelSize);
					}
				}

				mainAnimation = requestAnimationFrame(animate);
			}
			
			animate();
		}


		function stopAllAnimations() {
			// Stop main animation
			if (mainAnimation) {
				cancelAnimationFrame(mainAnimation);
			}
			
			// Stop all small canvas animations
			allAnimations.forEach(animationId => {
				cancelAnimationFrame(animationId);
			});
			allAnimations = [];
		}

		// Add keyboard shortcut to stop animations (ESC key)
		document.addEventListener('keydown', function(event) {
			if (event.key === 'Escape') {
				stopAllAnimations();
			}
		});

		// Function to create test videos with different pixel sizes (for testing)
		function createTestVideos() {
			const testPixelSizes = [4, 8, 16, 24, 32];
			const savedVideos = JSON.parse(localStorage.getItem('savedVideos') || '[]');
			
			// Only create test videos if we don't have enough variety
			if (savedVideos.length < 5) {
				testPixelSizes.forEach((size, index) => {
					// Create a simple test video data
					const testVideoData = {
						id: 'test_video_' + index,
						data: 'data:video/webm;base64,', // Placeholder
						timestamp: new Date().toISOString(),
						pixelSize: size
					};
					savedVideos.push(testVideoData);
				});
				localStorage.setItem('savedVideos', JSON.stringify(savedVideos));
				console.log('Created test videos with pixel sizes:', testPixelSizes);
			}
		}

		// Uncomment the line below to create test videos
		// createTestVideos();



        


	</script>


<script type="module">
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
    // TODO: Add SDKs for Firebase products that you want to use
    // https://firebase.google.com/docs/web/setup#available-libraries
  
    // Your web app's Firebase configuration
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
      apiKey: "AIzaSyAZp1CrD4A0yceTrQiyVSmbmLcOL-lYZc8",
      authDomain: "apartment-5abca.firebaseapp.com",
      projectId: "apartment-5abca",
      storageBucket: "apartment-5abca.firebasestorage.app",
      messagingSenderId: "94466801283",
      appId: "1:94466801283:web:62a58e33d915ea8711a5b6",
      measurementId: "G-BMKBC64ER4"
    };
  
    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);

    
  </script>

    

</body>
</html>
